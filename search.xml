<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2018%2F03%2F15%2Fhttp%2F</url>
    <content type="text"><![CDATA[当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 401 - 未授权HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 304协商缓存浏览器缓存分为强制缓存和协商缓存，优先读取强制缓存。强制缓存分为expires和cache-control，而expires是一个特定的时间，是比较旧的标准；cache-control通常是一个具体的时间长度，比较新，优先级也比较高。而协商缓存包括etag和last-modified，last-modified的设置标准是资源的上次修改时间，而etag是为了应对资源修改时间可能很频繁的情况出现的，是基于资源的内容计算出来的值，因此优先级也较高。协商缓存与强制缓存的区别在于强制缓存不需要访问浏览器，返回结果是200，协商缓存需要访问服务器，返回结果是304。 101协议升级主要用于websocket，也可以用于http2的升级http2支持单个连接多次请求，二进制，压缩头部，服务器推送。 307hts跳转原本的用法是用于让post请求的跳转去新的post请求，但也用于hsts跳转。hsts全称HTTP严格传输安全（HTTP Strict Transport Security，縮寫：HSTS），功能是要求浏览器下次访问该站点时使用https来访问，而不再需要先是http再转https。这样可以避免ssl剥离攻击，即攻击者在用户使用http访问的过程中进行攻击，对服务器冒充自己是用户，在攻击者和服务器中使用https访问，在用户和服务器中使用http访问。 具体使用方法是在服务器响应头中添加 Strict-Transport-Security，可以设置 max-age 301和302的区别字面上的区别就是301是永久重定向，而302是临时重定向。当然，他们之间也是有共同点的，就是用户都可以看到url替换为了一个新的，然后发出请求。 301比较常用的场景是使用域名跳转。 比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。 或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。 302用来做临时跳转。 比如未登陆的用户访问用户中心重定向到登录页面。 访问404页面会重新定向到首页。 302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。 而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练5]]></title>
    <url>%2F2018%2F03%2F06%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%835%2F</url>
    <content type="text"><![CDATA[1、Some players are playing a game: They stand in a circle, and each player has a card with the number on it. They put the card in front of their chest. That is to say, each player can see the numbers of other players, but can’t see his own. In each turn, each player adds up the numbers he sees and writes it to the new card. For example: There are 3 players: A,B and CThe original numbers of A,B,C is 1,0,4Let’s see the next 4 turns:123456Player: A B Cturn 0: 1 0 4turn 1: 4 5 1 // A:0+4;B:1+4;C:1+0turn 2: 6 5 9 // A:5+1;B:4+1;C:4+5turn 3: 14 15 11 // A:5+9;B:6+9;C:6+5turn 4: 26 25 29 // A:15+11;B:14+11;C:14+15 Hmm.. Your task is coming: Now, suppose you don’t know the original numbers. You are given the final numbers(an array) and turns(a positive integer), can you get the original numbers? ExamplesFor finalNumbers = [26,25,29] and turns = 4. The output should be [1,0,4]. The validation process can be referred to the above example. For finalNumbers = [1248,1226,1204,1182] and turns = 3. The output should be [12,34,56,78]. The validation process:12345Player: A B C Dturn 0: 12 34 56 78turn 1: 168 146 124 102turn 2: 372 394 416 438turn 3: 1248 1226 1204 1182 1234const originalNumbers = (arr,turns) =&gt; &#123; let s=arr.reduce((a,b)=&gt;a+b,0)/(arr.length-1); return turns?originalNumbers(arr.map(v=&gt;s-v),turns-1):arr;&#125; 2、Given integers n and k, find the kth divisor (1-based) of n or determine if n has less than k divisors(return -1). Input/Output [input] integer n 5 ≤ n ≤ 10^8. [input] integer k 1 ≤ k ≤ 20. [output] an integer The kth divisor of n or -1 if n has less than k divisors. Example For n = 63 and k = 4, the output should be 9. Divisors of number 63 are the following: 1, 3, 7, 9, 21, 63. For n = 5 and k = 3, the output should be -1. Number 5 has only 2 divisors. 123456789101112const kthDivisor = (n,k) =&gt; &#123; let arr=[]; for(let i = 1; i &lt;= n; i++) &#123; if(n % i === 0) &#123; arr.push(i); &#125; if(arr.length === k) &#123; return arr[k - 1] &#125; &#125; return -1&#125; 3、You are standing on top of an amazing Himalayan mountain. The view is absolutely breathtaking! you want to take a picture on your phone, but… your memory is full again! ok, time to sort through your shuffled photos and make some space… Given a gallery of photos, write a function to sort through your pictures. You get a random hard disk drive full of pics, you must return an array with the 5 most recent ones PLUS the next one (same year and number following the one of the last). You will always get at least a photo and all pics will be in the format YYYY.imgN 12sortPhotos[&quot;2016.img1&quot;,&quot;2016.img2&quot;,&quot;2015.img3&quot;,&quot;2016.img4&quot;,&quot;2013.img5&quot;]) ==[&quot;2013.img5&quot;,&quot;2015.img3&quot;,&quot;2016.img1&quot;,&quot;2016.img2&quot;,&quot;2016.img4&quot;,&quot;2016.img5&quot;]sortPhotos[&quot;2016.img1&quot;]) ==[&quot;2016.img1&quot;,&quot;2016.img2&quot;] 12345678910const sort = pics =&gt; &#123; let year = s =&gt; s.match(/(\d&#123;4&#125;)(.)/)[1]; let num = s =&gt; s.match(/(img)(\d+)/)[2]; pics.sort((a,b)=&gt;year(a)-year(b)||num(a)-num(b)) let mostRecent = pics.slice(pics.length-5); let next=mostRecent[mostRecent.length-1].replace(/\d+$/,x=&gt;x+1); mostRecent.push(next) return mostRecent&#125;sort([&quot;2016.img7&quot;,&quot;2016.img2&quot;,&quot;2016.img3&quot;,&quot;2015.img3&quot;,&quot;2012.img8&quot;,&quot;2016.img4&quot;,&quot;2016.img5&quot;]) 4、A consonant is any letter of the alphabet except a, e, i ,o, u. The consonant substrings in the word “zodiacs” are z, d, cs. Assuming a = 1, b = 2 … z = 26, the values of these substrings are 26 ,4, 22 because z = 26,d = 4,cs=3+19=22. The maximum value of these substrings is 26. Therefore, solve(“zodiacs”) = 26. Given a lowercase string that has alphabetic characters only and no spaces, return the highest value of consonant substrings. 12345678910111213const solve = s =&gt; &#123; let arr=[],str,res=[]; str= s.split(/a|i|o|u|e/g).map(el=&gt;&#123; let sum=0; el.split(&apos;&apos;).map(gg=&gt;&#123; sum+=gg.charCodeAt(0)-96; &#125;); res.push(sum) &#125;); res.sort((a,b)=&gt;b-a); return res[0]&#125;console.log(solve(&quot;zodiacaddfaeaera&quot;))]]></content>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练4]]></title>
    <url>%2F2018%2F03%2F05%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%834%2F</url>
    <content type="text"><![CDATA[1、简单模板字符串替换 123456const render = (template,context) =&gt; &#123; return template.replace(/\&#123;\&#123;(.*?)\&#125;\&#125;/g,(match,key) =&gt; context[key.trim()])&#125;const template = &quot;&#123;&#123;name &#125;&#125;很厉name害，才&#123;&#123;age &#125;&#125;岁&quot;;const context = &#123; name: &quot;xhh&quot;, age: &quot;18&quot; &#125;;console.log(render(template, context)); 2、You are going to be given a word. Your job is to return the middle character of the word. If the word’s length is odd, return the middle character. If the word’s length is even, return the middle 2 characters. 1234567Kata.getMiddle(&quot;test&quot;) should return &quot;es&quot;Kata.getMiddle(&quot;testing&quot;) should return &quot;t&quot;Kata.getMiddle(&quot;middle&quot;) should return &quot;dd&quot;Kata.getMiddle(&quot;A&quot;) should return &quot;A&quot; 123456789const getMiddle = str =&gt; &#123; let arr=str.split(&apos;&apos;); let res=[]; if(arr.length%2===0)&#123; res.push(arr[(arr.length/2)-1]); res.push(arr[arr.length/2]) &#125;else res.push(arr[(arr.length-1)/2]) return res.join(&apos;&apos;)&#125; 3、Some numbers have funny properties. For example: 89 –&gt; 8¹ + 9² = 89 * 1 695 –&gt; 6² + 9³ + 5⁴= 1390 = 695 * 2 46288 –&gt; 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51 Given a positive integer n written as abcd… (a, b, c, d… being digits) and a positive integer p we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n. In other words: Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + …) = n * k If it is the case we will return k, if not return -1. Note: n, p will always be given as strictly positive integers. 1234digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * kdigPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51 123456789101112131415const digPow = (n,p) =&gt; &#123; let x=String(n).split(&apos;&apos;).reduce((s,d,i)=&gt;s+Math.pow(d,p+i),0) return x%n?-1:x/n&#125;const digPow2 = (n,p) =&gt; &#123; let arr=n.toString().split(&apos;&apos;); let sum=0; for(let i=0;i&lt;arr.length;i++,p++)&#123; sum+=Math.pow(parseInt(arr[i]),p) &#125; for(let i=1;i*n&lt;=sum;i++)&#123; if(i*n===sum) return i &#125; return -1&#125; 4、Your task is to sort a given string. Each word in the String will contain a single number. This number is the position the word should have in the result. Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0). If the input String is empty, return an empty String. The words in the input String will only contain valid consecutive numbers. For an input: “is2 Thi1s T4est 3a” the function should return “Thi1s is2 3a T4est” 12your_order(&quot;is2 Thi1s T4est 3a&quot;)[1] &quot;Thi1s is2 3a T4est&quot; 12345678910111213141516171819const order2 = words =&gt; &#123; let arr=words.split(&apos; &apos;); let res=[] for(let i=0;i&lt;10;i++)&#123; for(let j=0;j&lt;arr.length;j++)&#123; if(arr[j].indexOf(i)!==-1)&#123; res.push(arr[j]) &#125; &#125; &#125; return res.join(&apos; &apos;);&#125;console.log(order(&quot;is2 Thi1s T4est 3a&quot;))const order = words =&gt; &#123; return words.split(&apos; &apos;).sort((a,b)=&gt;&#123; return a.match(/\d/)-b.match(/\d/) &#125;).join(&apos; &apos;)&#125; 5、Write a function that returns the count of characters that have to be removed in order to get a string with no consecutive repeats. Note: This includes any characters 123&apos;abbbbc&apos; =&gt; &apos;abc&apos; # answer: 3&apos;abbcca&apos; =&gt; &apos;abc&apos; # answer: 2&apos;ab cca&apos; =&gt; &apos;ab ca&apos; # answer: 1 1234567891011121314151617181920const countRepeats = str =&gt; &#123; let arr=str.split(&apos;&apos;); let count=0 for(let i=1;i&lt;arr.length;i++)&#123; if(arr[i]===arr[i-1]) &#123; i--; arr.splice(i,1); count++ &#125; &#125; return count&#125;const countRepeat2 = str =&gt; &#123; return (str.match(/(.)(?=\1)/g)||[]).length&#125;const countRepeat3 = str =&gt; &#123; let count=0,last; for(let ch of str) ch===last?count++:last=ch; return count&#125;]]></content>
      <categories>
        <category>codewars</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域和同源2]]></title>
    <url>%2F2018%2F03%2F05%2F%E8%B7%A8%E5%9F%9F2%2F</url>
    <content type="text"><![CDATA[CORS，Cross-origin resource sharing，跨域允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服Ajax只能同源使用的限制 CORS需要浏览器和服务器同时支持。整个CORS通信过程都由浏览器自动完成，不需要用户参与。对于开发者来说，CORS与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有请求所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不正常CORS的网站请求数据 详细参考：http://www.ruanyifeng.com/blog/2016/04/cors.html]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练3]]></title>
    <url>%2F2018%2F03%2F04%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%833%2F</url>
    <content type="text"><![CDATA[1、In this Kata, we will calculate the minumum number that is not possible sum from a list of integers.123solve([1,2,8,7]) = 4, because we can get 1, 2, 1+2=3. But 4 is the minimum number not possible from the list. solve([4,2,12,3,1]) = 11. We have 1, 2, 3, 4, 4+1=5, 4+2=6, 4+3=7,4+3+1=8,4+3+2=9,4+3+2+1=10. But no 11. solve([4,2,12,3]) = 1 12345678910const solve = arr =&gt; &#123; let sum=0; let newArr=arr.sort((a,b)=&gt;a-b); for (i of newArr)&#123; if (i &gt; sum +1) break; sum += i &#125; return sum + 1&#125;;console.log(solve([1,2,6,7])) 2、Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given numbers finds one that is different in evenness, and return a position of this number. ! Keep in mind that your task is to help Bob solve a real IQ test, which means indexes of the elements start from 1 (not 0) Examples : 123iqTest(&quot;2 4 7 8 10&quot;) =&gt; 3 // Third number is odd, while the rest of the numbers are eveniqTest(&quot;1 2 1 1&quot;) =&gt; 2 // Second number is even, while the rest of the numbers are odd 1234567const iqTest = numbers =&gt; &#123; let arr=numbers.split(&apos; &apos;); for(i of arr)&#123; arr[i]=parseInt(i)+1 &#125; return arr&#125; 3、Let’s create some scrolling text! Your task here is to write the function scrollingText, which takes a string, and returns an array: scrollingText(“codewars”) should return 12345678[&quot;CODEWARS&quot;,&quot;ODEWARSC&quot;,&quot;DEWARSCO&quot;,&quot;EWARSCOD&quot;,&quot;WARSCODE&quot;,&quot;ARSCODEW&quot;&quot;RSCODEWA&quot;,&quot;SCODEWAR&quot;] 12345678910const scrollingText = str =&gt; &#123; let arr=[]; arr[0]=str; for(let i=1;i=str.length;i++)&#123; str=str.slice(1)+str.slice(0,1) arr.push(str) &#125; return arr&#125;console.log(scrollingText(&apos;abcde&apos;)) 4、You probably know the “like” system from Facebook and other pages. People can “like” blog posts, pictures or other items. We want to create the text that should be displayed next to such an item. Implement a function likes :: [String] -&gt; String, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples: 12345likes [] // must be &quot;no one likes this&quot;likes [&quot;Peter&quot;] // must be &quot;Peter likes this&quot;likes [&quot;Jacob&quot;, &quot;Alex&quot;] // must be &quot;Jacob and Alex like this&quot;likes [&quot;Max&quot;, &quot;John&quot;, &quot;Mark&quot;] // must be &quot;Max, John and Mark like this&quot;likes [&quot;Alex&quot;, &quot;Jacob&quot;, &quot;Mark&quot;, &quot;Max&quot;] // must be &quot;Alex, Jacob and 2 others like this&quot; For more than 4 names, the number in and 2 others simply increases.12345678910const likes = names =&gt; &#123; names = names || []; switch(names.length)&#123; case 0: return &apos;no one likes this&apos;; break; case 1: return names[0] + &apos; likes this&apos;; break; case 2: return names[0] + &apos; and &apos; + names[1] + &apos; like this&apos;; break; case 3: return names[0] + &apos;, &apos; + names[1] + &apos; and &apos; + names[2] + &apos; like this&apos;; break; default: return names[0] + &apos;, &apos; + names[1] + &apos; and &apos; + (names.length - 2) + &apos; others like this&apos;; &#125;&#125; 5、Create your own mechanical dartboard that gives back your score based on the coordinates of your dart. Task: Use the scoring rules for a standard dartboard: Finish method: javascript function getDartboardScore(x, y); The coordinates are (x, y) are always relative to the center of the board (0, 0). The unit is millimeters. If you throw your dart 5 centimeters to the left and 3 centimeters below, it is written as: Possible scores are: Outside of the board: “X” Bull’s eye: “DB” Bull: “SB” A single number, example: “10” A triple number: “T10” A double number: “D10” A throw that ends exactly on the border of two sections results in a bounce out. You can ignore this because all the given coordinates of the tests are within the sections.The diameters of the circles on the dartboard are: Bull’s eye: 12.70 mm Bull: 31.8 mm Triple ring inner circle: 198 mm Triple ring outer circle: 214 mm Double ring inner circle: 324 mm Double ring outer circle: 340 mm123456789101112131415161718192021let values = [11, 14, 9, 12, 5, 20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11], angle = (1 - Math.atan2(y, x) / Math.PI) * 180, slice = values[Math.round(angle / 18)], dist = Math.sqrt(x * x + y * y); if (dist &gt; 170) return &apos;X&apos;; if (dist &lt;= 6.35) return &apos;DB&apos;; if (dist &lt;= 15.9) return &apos;SB&apos;; if (dist &gt;= 99 &amp;&amp; dist &lt;= 107) return &apos;T&apos; + slice; if (dist &gt;= 162 &amp;&amp; dist &lt;= 170) return &apos;D&apos; + slice; return &apos;&apos; + slice;]]></content>
      <categories>
        <category>codewars</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源和跨域1]]></title>
    <url>%2F2018%2F03%2F03%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[说到跨域，首先得知道什么是同源 同源策略同源即协议相同https://，端口相同8080，域名相同 www.zhy19950705.top 用于保护用户数据安全，防止cookie共享 如果是非同源的， Cookies、LocalStorage和IndexDB无法获取 Dom无法获取 Ajax请求受到限制 cookieCookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是如果两个网页的一级域名相同而二级域名不同的时候，浏览器是允许通过设置document.domain共享Cookie 12345document.domain=&apos;example.com&apos;document.cookie=&apos;test1=hello&apos;var allCookie=document.cookieSet-Cookie:key=value;domain=.example.com;path=/ iframe如果两个网页不同源，就无法拿到对方的DOM。比如iframe窗口和window.open打开的窗口与父窗口无法通信比如，父窗口运行以下代码，如果iframe窗口不同源，就会报错。1document.getElementById(&quot;myIFrame&quot;).contentWindow.document 以上代码中，父窗口想获取子窗口的DOM,因为跨域导致报错。同理，子窗口获取父窗口的DOM也会报错12window.parent.document.body` 如果两个窗口一级域名相同，二级域名不同，只要设置上面说到的document.domain，就可以规避同源，拿到DOM 对于不同源的网站，可以通过 片段识别符 window.name 跨文档通信API 获取DOM AJAX同源政策规定，AJAX请求只能发给同源的网址，否则报错 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务)，有三种方法规避1234JSONPWebSocketCORS` JSONP是服务器与客户端跨源通信的常用方法。最大的特点是简单适用，支持全部老式浏览器，服务器改造小。 它的基本思想是，网页通过添加一个script元素，向服务器请求JSON数据，这种做法，不受同源政策限制；服务器收到请求后，将数据放在同一个指定名字的回调函数里传回来。 首先网页动态插入script元素，由它向跨源网址发出请求。123456789101112131415function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;;` 上面代码通过动态添加script元素，向服务器example.com发出请求。注意，该请求有个callback参数，用来指定回调函数的名字。 服务器收到这个请求后，会将数据放在回调函数的参数位置返回。123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于script元素请求的脚本，直接作为代码被运行。这时，只要浏览器定义了foo函数，该函数就会立即被调用。作为参数的JSON数据被视为javascript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 Jquery使用JSONP12345678910111213141516jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); JSONP的要点就是运行客户端传一个callback参数给服务器，然后服务器返回数据时，会用callback参数作为函数名，包裹住JSON数据，返回客户端，客户端执行返回函数 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 表示该请求的请求源，即发自哪个域名 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练2]]></title>
    <url>%2F2018%2F03%2F02%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%832%2F</url>
    <content type="text"><![CDATA[1、I have a cat and a dog. I got them at the same time as kitten/puppy. That was humanYears years ago. Return their respective ages now as [humanYears,catYears,dogYears] NOTES: humanYears &gt;= 1 Cat Years 15 cat years for first year +9 cat years for second year +4 cat years for each year after that Dog Years 15 dog years for first year +9 dog years for second year +5 dog years for each year after that 123456const humanYearsCatYearsDogYears = humanYears =&gt; &#123; let res=[]; if(humanYears===1) return res=[1,15,15]; else if(humanYears===2) return res=[2,24,24]; else return res=[humanYears,(humanYears-2)*4+24,(humanYears-2)*5+24]&#125;; 2、Welcome. Welcome all to my very second Kata. As you know, the first one was a huge success with an approval rating of 97%. This time, however, things are going to be a little bit different. Is it going to be as cool as the last one? Let’s find out! Tell your friends! Given an integer b greater than 0, create and return a b X b matrix with the following pattern: 1234567891011 [x,1]matrixSquareUp(2) =&gt; [2,1] [x,x,1] [x,2,1]matrixSquareUp(3) =&gt; [3,2,1] [x,x,x,1] [x,x,2,1] [x,3,2,1]matrixSquareUp(4) =&gt; [4,3,2,1] Those are lowercase ‘x’. 50 &gt; b &gt; 0 1234567891011const matrixSquareUp =b =&gt; &#123; let res=[]; for(let i=0;i&lt;b;i++)&#123; res[i]=[] for(let j=0;j&lt;b;j++)&#123; res[i][j]=j&lt;i?&apos;x&apos;:b-j+&apos;&apos; &#125; &#125; return res.reverse()&#125;;console.log(matrixSquareUp(6)) 3、Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit.For example: 1234567persistence(39) === 3 // because 3*9 = 27, 2*7 = 14, 1*4=4 // and 4 has only one digitpersistence(999) === 4 // because 9*9*9 = 729, 7*2*9 = 126, // 1*2*6 = 12, and finally 1*2 = 2persistence(4) === 0 // because 4 is already a one-digit number 123456789const persistence = num =&gt; &#123; let times=0; num=num.toString(); while (num.length&gt;1)&#123; times++; num=num.split(&apos;&apos;).map(Number).reduce((a,b)=&gt;a*b).toString() &#125; return times&#125; 4、You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return -1. For example: Let’s say you are given the array {1,2,3,4,3,2,1}:Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6. Let’s look at another one.You are given the array {1,100,50,-51,1,1}:Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1. Last one:You are given the array {20,10,-80,10,10,15,35}At index 0 the left side is {}The right side is {10,-80,10,10,15,35}They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)Index 0 is the place where the left side and right side are equal. Note: Please remember that in most programming/scripting languages the index of an array starts at 0. Input:An integer array of length 0 &lt; arr &lt; 1000. The numbers in the array can be any integer positive or negative. Output:The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1. Note:If you are given an array with multiple answers, return the lowest correct index.An empty array should be treated like a 0 in this problem. 123456789const findEvenIndex = arr =&gt; &#123; for(let i=0;i&lt;arr.length-1;i++)&#123; let arr1=arr.slice(0,i); let arr2=arr.slice(i+1); if(arr1.length===0&amp;&amp;arr2.reduce((a,b)=&gt;a+b)===0) return 0; else if(arr1.length!==0&amp;&amp;arr1.reduce((a,b)=&gt;a+b)===arr2.reduce((a,b)=&gt;a+b)) return i; &#125; return -1&#125; 5、This time no story, no theory. The examples below show you how to write function accum: Examples: 123accum(&quot;abcd&quot;); // &quot;A-Bb-Ccc-Dddd&quot;accum(&quot;RqaEzty&quot;); // &quot;R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy&quot;accum(&quot;cwAt&quot;); // &quot;C-Ww-Aaa-Tttt&quot; The parameter of accum is a string which includes only letters from a..z and A..Z. 123const accum = s =&gt; &#123; return s.split(&apos;&apos;).map((c,i)=&gt;(c.toUpperCase()+c.toLowerCase().repeat(i))).join(&apos;-&apos;)&#125;]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练1]]></title>
    <url>%2F2018%2F03%2F01%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%2F</url>
    <content type="text"><![CDATA[1、Given a string of words, you need to find the highest scoring word. Each letter of a word scores points according to it’s position in the alphabet: a = 1, b = 2, c = 3 etc. You need to return the highest scoring word as a string. If two words score the same, return the word that appears earliest in the original string. All letters will be lowercase and all inputs will be valid. 123456789101112131415161718192021const high = s =&gt; &#123; let as=s.split(&apos; &apos;).map(s=&gt;[...s].reduce((a,b)=&gt;a+b.charCodeAt(0)-96,0)); return s.split(&apos; &apos;)[as.indexOf(Math.max(...as))]&#125;const high2 = x =&gt; &#123; let arr=x.toLowerCase().split(&apos; &apos;); let sum=0; let holder=0; let holder2=0; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=0;j&lt;arr[i].length;j++)&#123; sum+=arr[i].charCodeAt(j)-96; &#125; if(sum&gt;holder)&#123; holder=sum; holder2=i; &#125; sum=0 &#125; return arr[holder2]&#125; 2、In this Kata, you will be given a string and your task is to determine if that string can be a palindrome if we rotate one or more characters to the left. 12solve(&quot;4455&quot;) = true, because after 1 rotation, we get &quot;5445&quot; which is a palindromesolve(&quot;zazcbaabc&quot;) = true, because after 3 rotations, we get &quot;abczazcba&quot;, a palindrome More examples in test cases. Input will be strings of lowercase letters or numbers only. 12345678const solve = st =&gt; &#123; let t; for(let i=1;i&lt;st.length;i++)&#123; t=st.slice(i)+st.slice(0,i); if(t===[...t].reverse().join(&apos;&apos;)) return true &#125; return false&#125; 3、Given three arrays of integers, return the sum of elements that are common in all three arrays. For example: 12common([1,2,3],[5,3,2],[7,3,2]) = 5 because 2 &amp; 3 are common in all 3 arrayscommon([1,2,2,3],[5,3,2,2],[7,3,2,2]) = 7 because 2,2 &amp; 3 are common in the 3 arrays Array lengths in random tests run from 5000 to 10000 elements. 123456789101112const common = (a,b,c) =&gt; &#123; let com=[]; for(let i=0;i&lt;a.length;i++)&#123; let temp=a[i]; if(b.includes(temp)&amp;&amp;c.includes(temp))&#123; b.splice(b.indexOf(temp),1); c.splice(c.indexOf(temp),1); com.push(temp) &#125; &#125; return com.reduce((a,b)=&gt;a+b,0)&#125; 4、Leo’s girlfriend asked him to buy a gift list during his next trip, now he wants to know how many of them will he be able to buy. Write the following function to help Leo out: 1function howManyGifts(maxBudget, gifts) The first parameter is Leo’s budget; he second one is an array (a list in Groovy) containing the price of each gift. You should return an integer representing the maximum amount of gifts Leo can buy. Example:Maximum budget: 20Gift List: [13, 2, 4, 6, 1]Should return 4. 12345678const howManyGifts = (maxBudget,gifts) =&gt; &#123; let i=0; gifts=gifts.sort((a,b) =&gt; a-b); for(;maxBudget-gifts[i]&gt;=0;i++)&#123; maxBudget-=gifts[i] &#125; return i;&#125; 5、In this Kata, you will be given a string and your task will be to return a list of ints detailing the count of uppercase letters, lowercase, numbers and special characters, as follows. 12solve(&quot;*&apos;&amp;ABCDabcde12345&quot;) = [4,5,5,3]. --the order is: uppercase letters, lowercase, numbers and special characters. 123456789const solve = s =&gt; &#123; let res=[]; res.push(s.match(/[A-Z]/g).length); res.push(s.match(/[a-z]/g).length); res.push(s.match(/\d/g).length) res.push(s.match(/\W/g).length) return res&#125;console.log(solve(&quot;Codewars@codewars123.com&quot;))]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
