<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F03%2F03%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[CORS，Cross-origin resource sharing，跨域允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服Ajax只能同源使用的限制 同源策略同源即协议相同https://，端口相同8080，域名相同 www.zhy19950705.top 用于保护用户数据安全，防止cookie共享 如果是非同源的， Cookies、LocalStorage和IndexDB无法获取 Dom无法获取 Ajax请求受到限制 cookieCookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是如果两个网页的一级域名相同而二级域名不同的时候，浏览器是允许通过设置document.domain共享Cookie 12345document.domain=&apos;example.com&apos;document.cookie=&apos;test1=hello&apos;var allCookie=document.cookieSet-Cookie:key=value;domain=.example.com;path=/ iframe如果两个网页不同源，就无法拿到对方的DOM。比如iframe窗口和window.open打开的窗口与父窗口无法通信比如，父窗口运行以下代码，如果iframe窗口不同源，就会报错。1document.getElementById(&quot;myIFrame&quot;).contentWindow.document 以上代码中，父窗口想获取子窗口的DOM,因为跨域导致报错。同理，子窗口获取父窗口的DOM也会报错12window.parent.document.body` 如果两个窗口一级域名相同，二级域名不同，只要设置上面说到的document.domain，就可以规避同源，拿到DOM 对于不同源的网站，可以通过 片段识别符 window.name 跨文档通信API 获取DOM AJAX同源政策规定，AJAX请求只能发给同源的网址，否则报错 除了架设服务器代理(浏览器请求同源服务器，再由后者请求外部服务)，有三种方法规避1234JSONPWebSocketCORS` JSONP是服务器与客户端跨源通信的常用方法。最大的特点是简单适用，支持全部老式浏览器，服务器改造小。 它的基本思想是，网页通过添加一个元素，向服务器请求JSON数据，这种做法，不受同源政策限制；服务器收到请求后，将数据放在同一个指定名字的回调函数里传回来。 首先网页动态插入元素，由它向跨源网址发出请求。123456789101112131415function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;;` 上面代码通过动态添加元素，向服务器example.com发出请求。注意，该请求有个callback参数，用来指定回调函数的名字。 服务器收到这个请求后，会将数据放在回调函数的参数位置返回。123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于元素请求的脚本，直接作为代码被运行。这时，只要浏览器定义了foo函数，该函数就会立即被调用。作为参数的JSON数据被视为javascript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 Jquery使用JSONP12345678910111213141516jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到航班信息：票价： &apos; + json.price + &apos; 元，余票： &apos; + json.tickets + &apos; 张。&apos;); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); JSONP的要点就是运行客户端传一个callback参数给服务器，然后服务器返回数据时，会用callback参数作为函数名，包裹住JSON数据，返回客户端，客户端执行返回函数 WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 表示该请求的请求源，即发自哪个域名 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat CORSCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练2]]></title>
    <url>%2F2018%2F03%2F02%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%832%2F</url>
    <content type="text"><![CDATA[1、I have a cat and a dog. I got them at the same time as kitten/puppy. That was humanYears years ago. Return their respective ages now as [humanYears,catYears,dogYears] NOTES: humanYears &gt;= 1 Cat Years 15 cat years for first year +9 cat years for second year +4 cat years for each year after that Dog Years 15 dog years for first year +9 dog years for second year +5 dog years for each year after that 123456const humanYearsCatYearsDogYears = humanYears =&gt; &#123; let res=[]; if(humanYears===1) return res=[1,15,15]; else if(humanYears===2) return res=[2,24,24]; else return res=[humanYears,(humanYears-2)*4+24,(humanYears-2)*5+24]&#125;; 2、Welcome. Welcome all to my very second Kata. As you know, the first one was a huge success with an approval rating of 97%. This time, however, things are going to be a little bit different. Is it going to be as cool as the last one? Let’s find out! Tell your friends! Given an integer b greater than 0, create and return a b X b matrix with the following pattern: 1234567891011 [x,1]matrixSquareUp(2) =&gt; [2,1] [x,x,1] [x,2,1]matrixSquareUp(3) =&gt; [3,2,1] [x,x,x,1] [x,x,2,1] [x,3,2,1]matrixSquareUp(4) =&gt; [4,3,2,1] Those are lowercase ‘x’. 50 &gt; b &gt; 0 1234567891011const matrixSquareUp =b =&gt; &#123; let res=[]; for(let i=0;i&lt;b;i++)&#123; res[i]=[] for(let j=0;j&lt;b;j++)&#123; res[i][j]=j&lt;i?&apos;x&apos;:b-j+&apos;&apos; &#125; &#125; return res.reverse()&#125;;console.log(matrixSquareUp(6)) 3、Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit.For example: 1234567persistence(39) === 3 // because 3*9 = 27, 2*7 = 14, 1*4=4 // and 4 has only one digitpersistence(999) === 4 // because 9*9*9 = 729, 7*2*9 = 126, // 1*2*6 = 12, and finally 1*2 = 2persistence(4) === 0 // because 4 is already a one-digit number 123456789const persistence = num =&gt; &#123; let times=0; num=num.toString(); while (num.length&gt;1)&#123; times++; num=num.split(&apos;&apos;).map(Number).reduce((a,b)=&gt;a*b).toString() &#125; return times&#125; 4、You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return -1. For example: Let’s say you are given the array {1,2,3,4,3,2,1}:Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6. Let’s look at another one.You are given the array {1,100,50,-51,1,1}:Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1. Last one:You are given the array {20,10,-80,10,10,15,35}At index 0 the left side is {}The right side is {10,-80,10,10,15,35}They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)Index 0 is the place where the left side and right side are equal. Note: Please remember that in most programming/scripting languages the index of an array starts at 0. Input:An integer array of length 0 &lt; arr &lt; 1000. The numbers in the array can be any integer positive or negative. Output:The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1. Note:If you are given an array with multiple answers, return the lowest correct index.An empty array should be treated like a 0 in this problem. 123456789const findEvenIndex = arr =&gt; &#123; for(let i=0;i&lt;arr.length-1;i++)&#123; let arr1=arr.slice(0,i); let arr2=arr.slice(i+1); if(arr1.length===0&amp;&amp;arr2.reduce((a,b)=&gt;a+b)===0) return 0; else if(arr1.length!==0&amp;&amp;arr1.reduce((a,b)=&gt;a+b)===arr2.reduce((a,b)=&gt;a+b)) return i; &#125; return -1&#125; 5、This time no story, no theory. The examples below show you how to write function accum: Examples: 123accum(&quot;abcd&quot;); // &quot;A-Bb-Ccc-Dddd&quot;accum(&quot;RqaEzty&quot;); // &quot;R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy&quot;accum(&quot;cwAt&quot;); // &quot;C-Ww-Aaa-Tttt&quot; The parameter of accum is a string which includes only letters from a..z and A..Z. 123const accum = s =&gt; &#123; return s.split(&apos;&apos;).map((c,i)=&gt;(c.toUpperCase()+c.toLowerCase().repeat(i))).join(&apos;-&apos;)&#125;]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars每日一练1]]></title>
    <url>%2F2018%2F03%2F01%2Fcodewars%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%2F</url>
    <content type="text"><![CDATA[1、Given a string of words, you need to find the highest scoring word. Each letter of a word scores points according to it’s position in the alphabet: a = 1, b = 2, c = 3 etc. You need to return the highest scoring word as a string. If two words score the same, return the word that appears earliest in the original string. All letters will be lowercase and all inputs will be valid. 123456789101112131415161718192021const high = s =&gt; &#123; let as=s.split(&apos; &apos;).map(s=&gt;[...s].reduce((a,b)=&gt;a+b.charCodeAt(0)-96,0)); return s.split(&apos; &apos;)[as.indexOf(Math.max(...as))]&#125;const high2 = x =&gt; &#123; let arr=x.toLowerCase().split(&apos; &apos;); let sum=0; let holder=0; let holder2=0; for(let i=0;i&lt;arr.length;i++)&#123; for(let j=0;j&lt;arr[i].length;j++)&#123; sum+=arr[i].charCodeAt(j)-96; &#125; if(sum&gt;holder)&#123; holder=sum; holder2=i; &#125; sum=0 &#125; return arr[holder2]&#125; 2、In this Kata, you will be given a string and your task is to determine if that string can be a palindrome if we rotate one or more characters to the left. 12solve(&quot;4455&quot;) = true, because after 1 rotation, we get &quot;5445&quot; which is a palindromesolve(&quot;zazcbaabc&quot;) = true, because after 3 rotations, we get &quot;abczazcba&quot;, a palindrome More examples in test cases. Input will be strings of lowercase letters or numbers only. 12345678const solve = st =&gt; &#123; let t; for(let i=1;i&lt;st.length;i++)&#123; t=st.slice(i)+st.slice(0,i); if(t===[...t].reverse().join(&apos;&apos;)) return true &#125; return false&#125; 3、Given three arrays of integers, return the sum of elements that are common in all three arrays. For example: 12common([1,2,3],[5,3,2],[7,3,2]) = 5 because 2 &amp; 3 are common in all 3 arrayscommon([1,2,2,3],[5,3,2,2],[7,3,2,2]) = 7 because 2,2 &amp; 3 are common in the 3 arrays Array lengths in random tests run from 5000 to 10000 elements. 123456789101112const common = (a,b,c) =&gt; &#123; let com=[]; for(let i=0;i&lt;a.length;i++)&#123; let temp=a[i]; if(b.includes(temp)&amp;&amp;c.includes(temp))&#123; b.splice(b.indexOf(temp),1); c.splice(c.indexOf(temp),1); com.push(temp) &#125; &#125; return com.reduce((a,b)=&gt;a+b,0)&#125; 4、Leo’s girlfriend asked him to buy a gift list during his next trip, now he wants to know how many of them will he be able to buy. Write the following function to help Leo out: 1function howManyGifts(maxBudget, gifts) The first parameter is Leo’s budget; he second one is an array (a list in Groovy) containing the price of each gift. You should return an integer representing the maximum amount of gifts Leo can buy. Example:Maximum budget: 20Gift List: [13, 2, 4, 6, 1]Should return 4. 12345678const howManyGifts = (maxBudget,gifts) =&gt; &#123; let i=0; gifts=gifts.sort((a,b) =&gt; a-b); for(;maxBudget-gifts[i]&gt;=0;i++)&#123; maxBudget-=gifts[i] &#125; return i;&#125; 5、In this Kata, you will be given a string and your task will be to return a list of ints detailing the count of uppercase letters, lowercase, numbers and special characters, as follows. 12solve(&quot;*&apos;&amp;ABCDabcde12345&quot;) = [4,5,5,3]. --the order is: uppercase letters, lowercase, numbers and special characters. 123456789const solve = s =&gt; &#123; let res=[]; res.push(s.match(/[A-Z]/g).length); res.push(s.match(/[a-z]/g).length); res.push(s.match(/\d/g).length) res.push(s.match(/\W/g).length) return res&#125;console.log(solve(&quot;Codewars@codewars123.com&quot;))]]></content>
      <categories>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
